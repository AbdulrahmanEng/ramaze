#!/usr/bin/env ruby

def include_ramaze
  begin
    $:.unshift File.join(File.dirname(__FILE__), '/../lib')
    require 'ramaze'
  rescue LoadError
    $:.shift

    begin
      require 'rubygems'
    rescue LoadError
    end
    require 'ramaze'
  end
end

def usage
  <<-TXT
  Usage:

    ramaze <start [PIDFILE]|stop [PIDFILE]|restart [PIDFILE]|status [PIDFILE]|create PROJECT|console> [ruby/rack options]

    Commands:
      * All commands which take an optional PIDFILE default to PROJECT.pid if you do not supply one.
      * All commands which start a ramaze instance will default to webrick on port 7000 unless you supply
        the rack options -p/--port PORT and/or * -s/--server SERVER.

      start   - Starts an instance of this application.

      stop    - Stops a running instance of this application.

      restart - Stops running instance of this application, then starts it back up.  Pidfile
                (if supplied) is used for both stop and start.

      status  - Gives status of a running ramaze instance

      create  - Creates a new prototype Ramaze application in a directory named PROJECT in
                the current directory.  ramaze create foo would make ./foo containing an
                application prototype. Rack options are ignored here.

      console - Starts an irb console with app.rb (and irb completion) loaded. This command
                ignores rack options, ARGV is passed on to IRB.

    Rack Options
      #{%x{rackup --help}.split("\n").reject { |line| line.match(/^Usage:/) }.join("\n\t")}
  TXT
end

## Methods for commands {{{
def start
  # Find the name of this app
  app_name = default_pidfile.sub(/\.pid$/,'')
  added_args = []
  if daemonize = OURARGS.detect { |arg| arg.match(/^(-[dD]|--daemonize)$/) }
    if pid_arg = OURARGS.detect { |arg| arg.match(/^(-P|--pid)/) }
      puts "User supplied pid: #{pid_arg}"
      pid_file = OURARGS[OURARGS.index(pid_arg) + 1]
      puts "Starting daemon with user defined pidfile: #{pid_file}"
    else
      puts "Starting daemon with default pidfile: #{pid_file = default_pidfile}"
      added_args += ["-P", pid_file]
    end
    if check_running?(pid_file)
      $stderr.puts "Ramaze is already running with pidfile: #{pid_file}"
      exit 127
    end
  end
  added_args += ["-p", "7000"] unless OURARGS.detect { |arg| arg.match(/^(-p|--port)/) }
  added_args += ["-s", "webrick"] unless OURARGS.detect { |arg| arg.match(/^(-s|--server)/) }
  exec("rackup", "config.ru", *(ARGV + added_args))
end

def create(command)
  project_name = OURARGS[OURARGS.index(command) + 1]
  if project_name.nil?
    $stderr.puts "Must supply a project name" if project_name.nil?
    puts usage
    exit 1
  end
  opts = {}
  if OURARGS.detect { |arg| arg.match(/^(--force)/) }
    puts "Overwriting any existing files as requested."
    opts[:force] = true
  end
  if OURARGS.detect { |arg| arg.match(/^(--amend)/) }
    puts "Only amending missing files as requested."
    opts[:amend] = true
  end
  include_ramaze
  require 'ramaze/tool/create'
  Ramaze::Tool::Create.create(project_name, opts)
end

def stop(command)
  unless pid_file = find_pid(OURARGS[OURARGS.index(command) + 1])
    $stderr.puts "No pid_file found!  Cannot stop ramaze (may not be started)."
    return false
  end
  pid = File.read(pid_file).to_i
  puts "Stopping pid #{pid}"
  Process.kill("INT", pid)
  sleep 2
  if is_running?(pid)
    $stderr.puts "Process #{pid} did not die, forcing it with -9"
    Process.kill(9, pid)
    File.unlink(pid_file) if File.file?(pid_file)
    true
  else
    File.unlink(pid_file) if File.file?(pid_file)
    true
  end
end

def status(command)
  unless pid_file = find_pid(OURARGS[OURARGS.index(command) + 1])
    $stderr.puts "No pid_file found! Ramaze may not be started."
    exit 1
  end
  puts "Pid file #{pid_file} found, PID is #{pid = File.read(pid_file)}"
  unless is_running?(pid.to_i)
    $stderr.puts "PID #{pid} is not running"
    exit 1
  end
  if Object.const_defined?("WIN32OLE")
    wmi = WIN32OLE.connect("winmgmts://")
    processes, ours = wmi.ExecQuery("select * from win32_process where ProcessId = #{pid}"), []
    processes.each { |p| ours << [p.Name, p.CommandLine, p.VirtualSize, p.CreationDate, p.ExecutablePath, p.Status ] }
    puts "Ramaze is running!\n\tName: %s\n\tCommand Line: %s\n\tVirtual Size: %s\n\tStarted: %s\n\tExec Path: %s\n\tStatus: %s" % ours.first
  else
    require "pathname"
    # Check for /proc
    if File.directory?(proc_dir = Pathname.new("/proc"))
      proc_dir = proc_dir.join(pid)
      # If we have a "stat" file, we'll assume linux and get as much info
      # as we can
      if File.file?(stat_file = proc_dir.join("stat"))
        stats = File.read(stat_file).split
        puts "Ramaze is running!\n\tCommand Line: %s\n\tVirtual Size: %s\n\tStarted: %s\n\tExec Path: %s\n\tStatus: %s" % [
          File.read(proc_dir.join("cmdline")).split("\000").join(" "),
          "%s k" % (stats[22].to_f / 1024),
          File.mtime(proc_dir),
          File.readlink(proc_dir.join("exe")),
          stats[2]
        ]
        exit
      end
    end
    # Fallthrough status, just print a ps
    puts "Ramaze process #{pid} is running!"
    begin
      puts %x{ps l #{pid}}
    rescue
      puts "No further information available"
    end
  end
end

## End Command methods }}}

# Helper methods {{{
def default_pidfile
  return @default_pidfile if @default_pidfile
  @default_pidfile = (File.basename(File.expand_path(ENV["PWD"])) + ".pid").strip
end

def is_running?(pid)
  if Object.const_defined?("WIN32OLE")
    wmi = WIN32OLE.connect("winmgmts://")
    processes, ours = wmi.ExecQuery("select * from win32_process where ProcessId = #{pid}"), []
    processes.each { |process| ours << process.Name }
    ours.first.nil?
  else
    begin
      prio = Process.getpriority(Process::PRIO_PROCESS, pid)
      true
    rescue Errno::ESRCH
      false
    end
  end
end

def check_running?(pid_file)
  return false unless File.file?(pid_file)
  is_running?(File.read(pid_file).to_i)
end

def find_pid(pid_file)
  if pid_file.nil? or not File.file?(pid_file)
    pid_file = default_pidfile
  end
  unless File.file?(pid_file)
    $stderr.puts "Could not find running process id."
    return false
  end
  pid_file
end

## End helper methods }}}

OURARGS = ARGV.dup
command = ARGV.detect { |arg| arg.match(/^(?:--?)?(?:start|stop|restart|create|h(?:elp)?|v(?:ersion)?|console|status)/) }
if command.nil?
  command = ""
else
  ARGV.delete(command)
end

case command
when /^(?:--?)?status$/
  status(command)
when /^(?:--?)?restart$/
  stop(command)
  start
when /^(?:--?)?start$/
  start
when /^(?:--?)?create$/
  create(command)
when /^(?:--?)?stop$/
  if stop(command)
    puts "Ramazement has ended, go in peace."
    $stdout.flush
  else
    puts "Ramaze failed to stop (or was not running)"
  end
when /^(?:--?)?console$/
  require "ramaze"
  require "irb"
  require "irb/completion"
  Ramaze.options.started = true
  require "start"
  IRB.start
  puts "Ramazement has ended, go in peace."
when /^(?:--?)?h(elp)?$/
  puts usage
when /^(?:--?)?v(ersion)?$/
  include_ramaze
  puts Ramaze::VERSION
  exit
when /^$/
  puts "Must supply a valid command"
  puts usage
  exit 1
else
  puts "#{command} not implemented"
  puts usage
  exit 1
end

